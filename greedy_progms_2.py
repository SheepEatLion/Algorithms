def solution(number, k):
    stack = [number[0]]
    for n in number[1:]:
        while stack and stack[-1] < n and k > 0:
            k -= 1
            stack.pop()
        stack.append(n)
    if k != 0:
        return ''.join(stack[:-k])
    return ''.join(stack)

print(solution("4321", 2))

'''
[큰 수 만들기] - 그리디문제
1924라는 입력에서 k 만큼 제거하여 남은 수 중에서 가장 큰 수를 찾는 문제.
*순서가 유지된다.
ex) 1 9 2 4 -> 9, 4
ex) 1 2 3 1 2 3 4 -> 4xxx? -> 3234
ex) 4 1 7 7 2 5 2 8 4 1 -> 775841
ex) 4 1 7 7 2 9 2 8 4 1 -> 792841
연속적인 속성을 지켜가면서 그 안에서 최대한 큰 수를 뽑아낸다.
서로 붙어있는 두 수를 비교하면서 오른쪽으로 이동해야한다.
그래서 스택에 일단 0번째 값을 넣어두고 1번째부터 비교하면서 진행한다.
다만, 스택의 탑과 i 번째를 비교하는 방식이기 때문에 언제나 양옆의 값이 비교되게 하려면
우선 스택에 매 번째 값을 다 append 해줘야 한다.
그 다음에 pop 조건만 걸어주는게 좋은데, stack[-1]은 언제나 i-1 번째의 값이고 i 번째와 비교할 수 있다.
그래서 i 번째가 더 크다면 왼쪽으로 이동해야하기 때문에 스택을 pop 해주고 k를 제거했다는 의미로 -1 한다.
그래서 stack 이 비어있지 않고, 현재 값보다 옆의 값이 더 크고, k가 아직 있다면(제거 기회가 있다면)
현재 스택에서 비교한 값을 pop 해주고 또 비교한 값보다 작은 값이 여전히 스택에 있을 수 있으므로
while 문을 통해서 계속 비교해간다. 다 비교되었을 때 나와서 스택을 출력해주면 되는데
4321과 같이 while 조건문을 한번도 타지 않아서 k가 그대로 나오는 경우가 있다.
때문에 for 문이 종료되었을 때 여전히 k 가 0이 아닌지 판단해서 0이 아니라면 뒤에서부터 남아있는 k만큼
제거해준 뒤 출력해주면 된다.
'''
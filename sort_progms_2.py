
s1 = [10, 15, 300, 540, 2, 7]
s2 = ['10', '101', '1', '100']
#  101 100 10 1 = 101100101
#  101 1 10 100 = 101110100
print(sorted(s1), sorted(s2))

def solution(numbers):
    numbers = list(map(str, numbers))
    return str(int(''.join(sorted(numbers, reverse=True, key=lambda x: x*3))))


print(solution([3, 30, 34, 5, 9]))
print(type(solution([3, 30, 34, 5, 9])))
'''
우리가 가진 수 : 3, 30, 34, 5, 9
문자로 정렬하면 : 9, 5, 34, 30, 3
x*3을하면 : 333, 303030, 343434, 555, 999
이걸 정렬하면 : 999, 555, 343434, 333, 303030 -> 9, 5, 34, 3, 30
**핵심은 문자로 정렬할때는 기준이 다르다는 점.
= 문자로 정렬하면 사전순 정렬을 하기 때문에 각 문자열들의 앞자리를 비교하고 같다면 두번째 자리를 비교하는 식.
= 그래서 그냥 문자로 바꾼 뒤에 정렬해주면 위처럼 어느정도는 정렬이 되는데 30과 3은 아직 정렬이 안된 상태.
= 제한 사항에 보면 numbers의 원소가 0 이상 1000 이하라고 나와있음.
때문에 최소 1의 자리에서 최대 3의자리라고 보면됨. 왜냐면 4의 자리는 1000 하나밖에 없기 때문
그러니까 혹시라도 5와 555를 비교한다면 3번째자리까지 비교해야되니까 *3를 해주는 거임.
그렇게되면 555 와 555555555가 되니까 이 둘의 비교에도 문제가 없음.
'''

'''
[가장 큰 수] 정렬문제
조합으로 접근해야 하는 줄 알았지만, 리스트 최대 길이가 100,000이라서 시간초과 날 것.
입력받은 리스트의 각 숫자들의 맨 앞자리 (xx단위이면 10의 자리수, xxx단위면 100의 자리수)
를 비교해서 정렬하면 됨. 같다면 그 옆자리수 비교
'''
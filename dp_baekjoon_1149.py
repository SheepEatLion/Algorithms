import sys
n = int(sys.stdin.readline())
rgb = []
dp = [[0] * 3 for _ in range(n)]  # rgb 의 모양과 일치
#  rgb 비용 입력
for i in range(n):
    rgb.append(list(map(int, sys.stdin.readline().split())))
#  dp 초기값
dp[0][0] = rgb[0][0]
dp[0][1] = rgb[0][1]
dp[0][2] = rgb[0][2]

#  현재 i번째의 rgb 비용을 가져오고 dp에는 지금까지의 합들이 쌓이기 때문에
#  i-1번째에서 같은 색상이 아닌 경우 중, 비용이 더 적은 값을 가져와서 더해준다.
#  그렇게 더한 값을 현재 dp에 넣어서 반복한다.
for i in range(1, n):
    dp[i][0] = rgb[i][0] + min(dp[i-1][1], dp[i-1][2])
    dp[i][1] = rgb[i][1] + min(dp[i-1][0], dp[i-1][2])
    dp[i][2] = rgb[i][2] + min(dp[i-1][0], dp[i-1][1])
print(min(dp[n-1][0], dp[n-1][1], dp[n-1][2]))


'''
RGB로 직선 상의 집을 색칠하는데, i번째 집은 i-1번째와 i+1번째의 색과 달라야한다.
그리고 집을 칠하는데 색상별로 비용이 있어서 그 비용이 최소가 되게 칠하고 그 값을 출력한다.
처음 아이디어:
현재 칠하려는 집에서 최소비용 색상을 고른다.
고른 색상이 이전 집이 칠한 색인지 확인하고 맞다면 제외한 다른 색을 고르고 아니라면 그대로간다.

이렇게 생각해보니 이건 그리디 방식과 비슷하다.
그래서 그리디로 해도 될지 반례를 고민해보니, 불가능하다는 걸 알았다.
이 외에도 생각해보니까 반례들이 엄청 많다.
예를 들어 전부 1로 이루어져있는데 딱 한 값만 1000이면 이 값을 무조건 피해가야한다.
하지만 경우의 수가 엄청 까다로워지고 구현에 예외처리 할 것들이 엄청 많다.

dp 문제로 분류되어 있는 걸 보고 dp 라는 걸 알았지만 도저히 방향을 못잡았다.
반복되는 부분은 i번째에서 i-1번째의 겹치지 않는 색상을 선택한다는 것인데 시작점을 못생각했다.
결국 다른분들의 코드를 참고해보니, RGB를 각각 나눠서 3개로 DP를 한 다음에
그 중에서 최소비용을 min() 으로 꺼내는 방식이었다.

'''
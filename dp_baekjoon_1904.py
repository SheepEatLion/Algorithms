import sys
n = int(sys.stdin.readline())
cache_1 = 1
cache_2 = 2
if n == 1:
    print(cache_1)
    sys.exit()
elif n == 2:
    print(cache_2)
    sys.exit()
for i in range(2, n):
    cache_1, cache_2 = cache_2, (cache_1+cache_2) % 15746
print(cache_2)

'''
1과 00만을 무한으로 사용가능할 때 주어진 n의 2진 수열 개수를 출력하는 문제.
N값
1  1  = 1개
2  11, 00 = 2개 
3  111, 100, 001 = 3개
4  1111, 1100, 1001, 0011, 0000 = 5개
5  11111, 11100, 11001, 10011, 00111, 10000, 00100, 00001 = 8개
6  111111, 111100, 111001, 110011, 100111, 001111, 110000, 100100, 100001, 000011, 001001, 001100, 000000 = 13개

풀이 과정:
처음에는 어떻게 접근해야할 지 감이 안잡혔다. 경우의 수를 구하는건데 조건이 있으니까 백트래킹을 해야하나 싶었는데
다행히도 DP로 푸는 문제라는 걸 알려줘서 삽질은 면했다.
DP로 푼다는 얘기는 즉슨 재귀구조가 있다는 거고 최적화 문제가 있다는 것라서 일단 예시를 써내렸다.
N=5 인 경우까지 쓰고보니 피보나치처럼 이전의 값 2개를 더하면 현재 값이 나왔다.
좀 더 확실히 하기 위해 N=6 인 경우까지 구했고 확신할 수 있었다.
그래서 첫 코드는 아래처럼 피보나치와 비슷하게 코딩했다.
'''
'''
import sys
n = int(sys.stdin.readline())
dp = [0] * 1000001
dp[0] = 1
dp[1] = 2
if n == 1:
    print(dp[0])
    sys.exit()
elif n == 2:
    print(dp[1])
    sys.exit()
for i in range(2, n):
    dp[i] = dp[i-1] + dp[i-2]
print(dp[n-1] % 15746)
'''
'''
이렇게 코딩하니까 메모리초과가 났다.
N에 최대 입력값이 백만이라서 리스트를 최대 백만개를 만들어주고 시작하기 때문이었다.
어떻게 할까 고민하다 문득 이전 값들을 다 메모할 필요는 없고 바로 두 값만 알면 된다는 걸 깨달았다.
그래서 가장 위의 정답코드처럼 dp 리스트를 지우고 변수 2개로 바꿨다.
그리고 나서도 시간초과 에러가 났었는데 15746으로 나눈 나머지 출력을 for 안에서 하지 않고 다 끝난 뒤에 최종 출력에서만 해서 그랬다.
for 문 안에두면 오히려 계산을 여러번 하니까 다 나와서 한번만 하는게 이득일거라고 생각했는데
시간초과가 나는거보니 아무래도 계산할 값이 폭증하는 걸로 보인다. 그래서 줄일 수 있을 때마다 줄여주는게 오히려 계산 속도를 높여서 현재의 정답코드가 나왔다.
'''